# Sorting Algorithms

Welcome to the Sorting Algorithms repository! This collection includes implementations of various sorting algorithms, each with its own folder and accompanying notes. These algorithms are commonly used for ordering elements in a list or array.

## Algorithms Included

### 1. Bubble Sort

- **Time Complexity:** O(n^2) - worst and average case, O(n) - best case (already sorted)
- **Space Complexity:** O(1)
- **In-Place:** Yes
- **Stability:** Yes

Bubble Sort is a simple comparison-based sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.

### 2. Selection Sort

- **Time Complexity:** O(n^2) - worst, average, and best case
- **Space Complexity:** O(1)
- **In-Place:** Yes
- **Stability:** No

Selection Sort works by dividing the array into a sorted and an unsorted region. It repeatedly selects the minimum element from the unsorted region and swaps it with the first element of the unsorted region.

### 3. Insertion Sort

- **Time Complexity:** O(n^2) - worst and average case, O(n) - best case (almost sorted)
- **Space Complexity:** O(1)
- **In-Place:** Yes
- **Stability:** Yes

Insertion Sort builds the final sorted array one element at a time. It is a simple and intuitive sorting algorithm that is efficient for small datasets.

### 4. Merge Sort

- **Time Complexity:** O(n log n) - worst, average, and best case
- **Space Complexity:** O(n)
- **In-Place:** No
- **Stability:** Yes

Merge Sort is a divide-and-conquer algorithm that divides the input array into two halves, recursively sorts them, and then merges the sorted halves.

### 5. Quick Sort

- **Time Complexity:** O(n^2) - worst case (rare), O(n log n) - average and best case
- **Space Complexity:** O(log n)
- **In-Place:** Yes
- **Stability:** No

Quick Sort is a highly efficient and widely used sorting algorithm based on the divide-and-conquer strategy. It partitions the array into smaller segments, recursively sorts them, and combines the results.

ðŸ§© 
